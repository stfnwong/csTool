function varargout = gui_genImHist(varargin)
% GUI_GENIMHIST
% Generate image histogram for csToolGUI. 
% This function generates the image histogram for a frame in csToolGUI. The function
% can produce histograms for full images (default) or for regions of an image using
% the 'region', region name/value argument. Model histograms should be generated by
% the csSegementer object in the csToolGUI.
% Note that only one of fh or image is required. If the image is not available in the
% calling context, but a frame handle is, then use 'fh',fh and gui_genImHist() will
% read the image in from the frame handles 'filename' property. If the image has been
% read in the caller already, then the image can be passed directly with a 'img' 
% tag in front.
%
% CHANGES: To speed up frame browsing, the csFrame class now buffers a copy
% of the image histogram for that frame. If a frame handle is passed in,
% the function will first check to see if there is an existing imhist, and
% only if not present will a new one be generated. To clear old imhist
% values from the frame handles, use the clearImHist() method in
% csFrameBuffer.
%
% ARGUMENTS:
% 'fh', fh         - Frame handle of image to generate histogram for
% 'img', img       - Image to generate histogram for
% 'region', region - (Optional) Generate histogram for the region specified by region.
% 'nbins', N       - Set the number of bins to N
% 'fpgaMode'       - Use naive histogram method in $CSTOOL_DIR/util (slow)
% 

% Stefan Wong 2013

	%Set internal constants
	FPGA_MODE = 0;
	DEBUG     = 0;
	HSV       = 0;
	N_BINS    = 16;
	DATA_SZ   = 256;

	if(~isempty(varargin))
		for k = 1:length(varargin)
			if(ischar(varargin{k}))
				if(strncmpi(varargin{k}, 'fh', 2))
					fh = varargin{k+1};
				elseif(strncmpi(varargin{k}, 'img', 3))
					img = varargin{k+1};
				elseif(strncmpi(varargin{k}, 'region', 6))
					region = varargin{k+1};
				elseif(strncmpi(varargin{k}, 'hsv', 3))
					HSV = 1;
				elseif(strncmpi(varargin{k}, 'nbins', 5))
					N_BINS = varargin{k+1};
				elseif(strncmpi(varargin{k}, 'data', 4) || ...
                       strncmpi(varargin{k}, 'size', 4))
					DATA_SZ = varargin{k+1};
				elseif(strncmpi(varargin{k}, 'fpga', 4))
					FPGA_MODE = 1;
				elseif(strncmpi(varargin{k}, 'debug', 5))
					DEBUG = 1;
				
				end
			end
		end
	end

	%Check for not enough args
	if(~exist('fh', 'var') && ~exist('img', 'var'))
		fprintf('ERROR: No fh or img data passed in\n');
		varargout{1} = zeros(1, N_BINS);
		return;
	end
	%Check for frame handle first, look for imhist
	if(exist('fh', 'var'))
		if(isempty(get(fh, 'ihist')))
			%Load image from disk
			img  = imread(get(fh, 'filename'), 'TIFF');
			dims = size(img);
			if(dims(3) > 3)
				img = img(:,:,1:3);
			end
		else
			%This could be a set of 3 histograms (RGB), so test dimensions
			%before returning a value
			ihist = get(fh, 'ihist');
			sz    = size(ihist);
			if(sz(1)  == 3)
				switch nargout
					case 1
						varargout{1} = ihist(1,:);
					case 2
						varargout{1} = ihist(1,:);
						varargout{2} = ihist(2,:);
					case 3
						varargout{1} = ihist(1,:);
						varargout{2} = ihist(2,:);
						varargout{3} = ihist(3,:);
				end
			else
				varargout{1} = ihist;
			end
			return;
		end
	end

	if(FPGA_MODE)
		fprintf('UNDER DEVELOPMENT (use util/gen_fpgaHist())\n');
		ihist = zeros(1,N_BINS);
		if(exist('fh', 'var'))
			set(fh, 'ihist', ihist);
		end
		varargout{1} = ihist;
	else
		if(HSV)
			hsvimg       = rgb2hsv(img);
			hueimg       = DATA_SZ.*hsvimg(:,:,1);
			ihist        = imhist(hueimg, N_BINS);
			if(exist('fh', 'var'))
				set(fh, 'ihist', ihist);
			end
			varargout{1} = ihist;
		else
			ihist = zeros(nargout, N_BINS);
			for k = 1:nargout
				%varargout{k} = imhist(img(:,:,k), N_BINS);
				ihist(k,:) = imhist(img(:,:,k), N_BINS);
			end
			if(exist('fh', 'var'))
				set(fh, 'ihist', ihist);
			end
		end
	end
	
end 	%gui_genImHist()
